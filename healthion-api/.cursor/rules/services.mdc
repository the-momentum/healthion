---
globs: app/services/**,app/utils/exceptions.py
alwaysApply: false
---

# Services Layer

**Type annotations are mandatory for all parameters and return types.**

## Location

Services are located in `app/services/` directory.

## Purpose

Services contain business logic and are designed for routes. They **NEVER** perform database operations directly - repositories handle all database operations.

## Data types

### Input/Output
- **SQLAlchemy models** - Required for input (from repositories) and output (when returning database entities)
- **Pydantic schemas** - Can be used internally for operations not involving repositories (e.g., file processing)

## Service types

### CRUD services
For database entity operations, inherit from `AppService`:

```python
from app.services.services import AppService
from app.repositories.user_repository import UserRepository
from app.models.user import User
from app.schemas.user import UserCreate, UserUpdate
from logging import Logger

class UserService(AppService[UserRepository, User, UserCreate, UserUpdate]):
    def __init__(
        self, 
        crud_model: type[UserRepository], 
        model: type[User], 
        log: Logger, 
        **kwargs
    ) -> None:
        super().__init__(crud_model, model, log, **kwargs)

# Initialize service instance
user_service = UserService(UserRepository, User, logger)
```

### Mixin services
Combine CRUD operations with additional functionality using Cooperative Inheritance:

```python
class ActivityMixin:
    def __init__(self, activity_repository: ActivityRepository = Depends(), **kwargs):
        self.activity_repository = activity_repository
        super().__init__(**kwargs)

    @handle_exceptions
    def is_user_active(self: "UserService", object_id: UUID) -> bool:
        self.logger.info(f"Checking if user with ID: {object_id} is active.")
        return self.activity_repository.is_user_active(object_id)

class UserService(AppService[UserRepository, User, UserCreate, UserUpdate], ActivityMixin):
    def __init__(
        self, 
        crud_model: type[UserRepository], 
        model: type[User], 
        log: Logger, 
        **kwargs
    ) -> None:
        super().__init__(crud_model, model, log, **kwargs)
```

## Error handling

- Use `@handle_exceptions` decorator from `app.utils.exceptions`
- Decorator uses single dispatch pattern for exception handling
- Add new exception handlers by class type

## Service instantiation

- Always initialize service class for import by routes
- Use dependency injection for repositories (in mixin services)
- Pass logger instance to constructor

## Service flow

repository → SQLAlchemy model -> (mixin service ->) service-> SQLAlchemyModel (usually) → route